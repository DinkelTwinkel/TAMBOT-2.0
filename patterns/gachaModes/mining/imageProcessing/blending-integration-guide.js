// TILESET BLENDING INTEGRATION GUIDE\n// ===================================\n\n/* \n * This guide shows how to integrate the tileset blending system\n * with your existing mining renderer.\n */\n\n// === STEP 1: Import the blending functions ===\nconst {\n    analyzeMineProgression,\n    calculateBlendingPercentage, \n    getBlendedTileTheme,\n    debugMineProgression,\n    TIER_GROUPS\n} = require('./tileset-blender');\n\n// === STEP 2: Enhance your tile loading function ===\n/*\n * Modify your existing loadTileImageVariation function to use position-aware theming:\n */\n\n// BEFORE (original approach):\n// const floorImage = await loadTileImageVariation(TILE_TYPES.FLOOR, theme, variationSeed);\n\n// AFTER (with blending support):\n// const floorImage = await loadTileImageVariationBlended(\n//     TILE_TYPES.FLOOR, \n//     theme, \n//     variationSeed, \n//     dbEntry,     // Database entry with typeId\n//     x, y,        // Tile coordinates \n//     channelId    // Discord channel ID for consistent seeding\n// );\n\nasync function loadTileImageVariationBlended(tileType, baseTheme, variationSeed, dbEntry, tileX, tileY, channelId) {\n    // Get the blended theme for this specific tile position\n    const actualTheme = getBlendedTileThemeForTile(dbEntry, tileX, tileY, tileType, channelId);\n    \n    // Use the blended theme instead of the base theme\n    return await loadTileImageVariation(tileType, actualTheme, variationSeed);\n}\n\nfunction getBlendedTileThemeForTile(dbEntry, tileX, tileY, tileType, channelId) {\n    const typeId = dbEntry?.typeId;\n    if (!typeId) return 'generic';\n    \n    const gachaServers = require('../../../../data/gachaServers.json');\n    return getBlendedTileTheme(String(typeId), tileX, tileY, tileType, channelId, gachaServers);\n}\n\n// === STEP 3: Update your floor rendering ===\n/*\n * In your drawFloorLayer function, replace the tile loading calls:\n */\n\n// EXAMPLE: Enhanced floor tile rendering with blending\nasync function drawFloorTileWithBlending(ctx, x, y, tileSize, theme, dbEntry, channelId) {\n    const variationSeed = (x * 7 + y * 13) % 100;\n    \n    // ENHANCED: Use blended theme\n    const floorImage = await loadTileImageVariationBlended(\n        'floor', \n        theme, \n        variationSeed, \n        dbEntry, \n        x, y, \n        channelId\n    );\n    \n    const pixelX = x * tileSize;\n    const pixelY = y * tileSize;\n    \n    // Rotation logic (same as original)\n    const channelHash = parseInt(channelId.slice(-6), 16) || 0x123456;\n    const rotationSeed = channelHash + x * 1337 + y * 7919;\n    const rotation = Math.floor(seededRandom(rotationSeed) * 4) * 90;\n    \n    ctx.save();\n    ctx.translate(pixelX + tileSize/2, pixelY + tileSize/2);\n    ctx.rotate(rotation * Math.PI / 180);\n    \n    if (floorImage) {\n        ctx.drawImage(floorImage, -tileSize/2, -tileSize/2, tileSize, tileSize);\n    } else {\n        // Fallback rendering\n        ctx.fillStyle = '#D2B48C';\n        ctx.fillRect(-tileSize/2, -tileSize/2, tileSize, tileSize);\n    }\n    \n    ctx.restore();\n}\n\n// === STEP 4: Update your wall rendering ===\n/*\n * Similarly for walls:\n */\n\nasync function drawWallTileWithBlending(ctx, tile, x, y, floorTileSize, wallTileHeight, theme, dbEntry, channelId) {\n    const variationSeed = (x * 11 + y * 17) % 100;\n    \n    // ENHANCED: Use blended theme\n    const wallImage = await loadTileImageVariationBlended(\n        tile.type, \n        theme, \n        variationSeed, \n        dbEntry, \n        x, y, \n        channelId\n    );\n    \n    const pixelX = x * floorTileSize;\n    const pixelY = y * floorTileSize;\n    const wallPixelY = pixelY + floorTileSize - wallTileHeight;\n    \n    // Flip logic (same as original)\n    const channelHash = parseInt(channelId.slice(-6), 16) || 0x123456;\n    const flipSeed = channelHash + x * 2347 + y * 3571;\n    const shouldFlip = seededRandom(flipSeed) > 0.5;\n    \n    if (wallImage) {\n        ctx.save();\n        if (shouldFlip) {\n            ctx.translate(pixelX + floorTileSize, wallPixelY);\n            ctx.scale(-1, 1);\n            ctx.drawImage(wallImage, 0, 0, floorTileSize, wallTileHeight);\n        } else {\n            ctx.drawImage(wallImage, pixelX, wallPixelY, floorTileSize, wallTileHeight);\n        }\n        ctx.restore();\n    }\n}\n\n// === STEP 5: Debug the blending ===\n/*\n * Add debugging to see what's happening:\n */\n\nfunction debugCurrentMineBlending(dbEntry) {\n    const typeId = dbEntry?.typeId;\n    if (!typeId) return;\n    \n    const gachaServers = require('../../../../data/gachaServers.json');\n    const progression = analyzeMineProgression(String(typeId), gachaServers);\n    \n    if (progression) {\n        console.log(`\\n=== CURRENT MINE BLENDING INFO ===`);\n        console.log(`Mine: ${progression.mineEntry.name}`);\n        console.log(`Level: ${progression.level} (Deep: ${progression.isDeepLevel})`);\n        console.log(`Current tier: ${progression.currentTierTheme}`);\n        console.log(`Next tier: ${progression.nextTierTheme || 'None'}`);\n        console.log(`Blend percentage: ${calculateBlendingPercentage(progression)}%`);\n        console.log(`Is transitioning: ${progression.isDeepLevel && !progression.isLastTier}`);\n        console.log(`====================================\\n`);\n    }\n}\n\n// === STEP 6: Usage in your main render function ===\n/*\n * In your main generateTileMapImage function:\n */\n\nasync function generateTileMapImageWithBlending(channel, options = {}) {\n    // ... existing setup code ...\n    \n    const result = await gachaVC.findOne({ channelId: channel.id });\n    const { tiles, width, height } = result.gameData.map;\n    \n    // Debug blending if requested\n    if (options.debug) {\n        debugCurrentMineBlending(result);\n        debugMineProgression(require('../../../../data/gachaServers.json'));\n    }\n    \n    // ... rest of rendering code ...\n    \n    // When rendering floors:\n    for (let y = 0; y < height; y++) {\n        for (let x = 0; x < width; x++) {\n            const tile = tiles[y] && tiles[y][x];\n            if (tile && tile.type === 'floor') {\n                await drawFloorTileWithBlending(ctx, x, y, tileSize, baseTheme, result, channel.id);\n            }\n        }\n    }\n    \n    // When rendering walls:\n    for (let y = 0; y < height; y++) {\n        for (let x = 0; x < width; x++) {\n            const tile = tiles[y] && tiles[y][x];\n            if (tile && (tile.type === 'wall' || tile.type === 'wall_ore')) {\n                await drawWallTileWithBlending(ctx, tile, x, y, floorTileSize, wallTileHeight, baseTheme, result, channel.id);\n            }\n        }\n    }\n    \n    // ... rest of rendering ...\n}\n\n// === STEP 7: Test the system ===\n/*\n * Test with different mine levels to see the blending:\n */\n\nfunction testBlendingSystem() {\n    const gachaServers = require('../../../../data/gachaServers.json');\n    const channelId = 'test123456789';\n    \n    // Test different levels of coal mines\n    const testMines = ['1001', '1002', '1003', '1004', '1005']; // L-1 through L-5\n    \n    testMines.forEach(mineId => {\n        console.log(`\\n--- Testing Mine ID: ${mineId} ---`);\n        const progression = analyzeMineProgression(mineId, gachaServers);\n        if (progression) {\n            console.log(`${progression.mineEntry.name}`);\n            console.log(`Blend: ${calculateBlendingPercentage(progression)}%`);\n            \n            // Test a few tile positions\n            for (let i = 0; i < 5; i++) {\n                const x = i * 3;\n                const y = i * 2;\n                const theme = getBlendedTileTheme(mineId, x, y, 'floor', channelId, gachaServers);\n                console.log(`  Tile (${x}, ${y}): ${theme}`);\n            }\n        }\n    });\n}\n\n// === SUMMARY ===\n/*\n * The blending system works as follows:\n * \n * 1. For L0 levels (like \"Coal Mines L0\"): No blending, use current tier's tileset\n * \n * 2. For intermediate levels (L-1 through L-5):\n *    - L-1: 5% chance to use next tier's tiles\n *    - L-2: 25% chance to use next tier's tiles  \n *    - L-3: 45% chance to use next tier's tiles\n *    - L-4: 65% chance to use next tier's tiles\n *    - L-5: 90% chance to use next tier's tiles\n * \n * 3. The choice is consistent per tile position using seeded RNG based on:\n *    - Channel ID (for server-specific consistency)\n *    - Tile coordinates (x, y)\n *    - Tile type (floor, wall, etc.)\n * \n * 4. This creates natural-looking transitions where you gradually see more \n *    of the next tier's theme as you progress through the intermediate levels.\n * \n * 5. The system automatically detects tier groups (coal -> coalDeep -> coalUltra)\n *    and handles the progression between them.\n */\n\nmodule.exports = {\n    loadTileImageVariationBlended,\n    drawFloorTileWithBlending,\n    drawWallTileWithBlending,\n    debugCurrentMineBlending,\n    generateTileMapImageWithBlending,\n    testBlendingSystem\n};