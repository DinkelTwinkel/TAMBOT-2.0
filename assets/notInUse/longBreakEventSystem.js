// longBreakEventSystem.js - Separate event system for mining long breaks
const { EmbedBuilder, AttachmentBuilder } = require('discord.js');
const Currency = require('../models/currency');
const PlayerInventory = require('../models/inventory');
const gachaVC = require('../models/activevcs');

// ---------------- Event System Core ----------------

/**
 * Long Break Event Manager
 * Handles special events that occur during long breaks (every 4th break)
 */
class LongBreakEventManager {
    constructor() {
        this.events = [
            { name: 'thief', func: this.startThiefGame.bind(this), weight: 100, duration: 10 * 60 * 1000 }, // 10 minutes
            { name: 'cave_in', func: this.startCaveInEvent.bind(this), weight: 50, duration: 8 * 60 * 1000 }, // 8 minutes
            { name: 'treasure_hunt', func: this.startTreasureHunt.bind(this), weight: 75, duration: 12 * 60 * 1000 }, // 12 minutes
            { name: 'gas_leak', func: this.startGasLeakEvent.bind(this), weight: 60, duration: 6 * 60 * 1000 } // 6 minutes
        ];\n        \n        this.activeEvents = new Map(); // channelId -> eventData\n    }\n\n    /**\n     * Start a random long break event\n     */\n    async startRandomEvent(channel, dbEntry, logEventFunc) {\n        const members = channel.members.filter(m => !m.user.bot);\n        if (members.size < 2) {\n            await logEventFunc(channel, '‚ö†Ô∏è Not enough players for special event. Extending break...');\n            return null;\n        }\n\n        const event = this.pickWeightedEvent();\n        const eventData = {\n            type: event.name,\n            startTime: new Date(),\n            endTime: new Date(Date.now() + event.duration),\n            channelId: channel.id\n        };\n\n        // Store event in database\n        await this.setSpecialEvent(channel.id, eventData);\n        this.activeEvents.set(channel.id, eventData);\n\n        // Start the specific event\n        await event.func(channel, dbEntry, members, logEventFunc);\n        \n        return eventData;\n    }\n\n    /**\n     * Check if an event should end and handle cleanup\n     */\n    async checkEventEnd(channel, dbEntry, logEventFunc) {\n        const eventData = this.activeEvents.get(channel.id) || dbEntry.gameData?.specialEvent;\n        if (!eventData) return false;\n\n        const now = Date.now();\n        if (now >= eventData.endTime.getTime()) {\n            await this.endEvent(channel, dbEntry, eventData, logEventFunc);\n            return true;\n        }\n        return false;\n    }\n\n    /**\n     * End the current event and handle rewards/cleanup\n     */\n    async endEvent(channel, dbEntry, eventData, logEventFunc) {\n        switch (eventData.type) {\n            case 'thief':\n                await this.endThiefGame(channel, dbEntry, logEventFunc);\n                break;\n            case 'cave_in':\n                await this.endCaveInEvent(channel, dbEntry, logEventFunc);\n                break;\n            case 'treasure_hunt':\n                await this.endTreasureHunt(channel, dbEntry, logEventFunc);\n                break;\n            case 'gas_leak':\n                await this.endGasLeakEvent(channel, dbEntry, logEventFunc);\n                break;\n        }\n\n        // Cleanup\n        await this.clearSpecialEvent(channel.id);\n        this.activeEvents.delete(channel.id);\n    }\n\n    /**\n     * Pick a weighted random event\n     */\n    pickWeightedEvent() {\n        const totalWeight = this.events.reduce((sum, e) => sum + e.weight, 0);\n        let rand = Math.random() * totalWeight;\n        return this.events.find(e => (rand -= e.weight) < 0) || this.events[0];\n    }\n\n    // ---------------- Database Helpers ----------------\n\n    async setSpecialEvent(channelId, eventData) {\n        await gachaVC.updateOne(\n            { channelId: channelId },\n            { $set: { 'gameData.specialEvent': eventData } }\n        );\n    }\n\n    async clearSpecialEvent(channelId) {\n        await gachaVC.updateOne(\n            { channelId: channelId },\n            { $unset: { 'gameData.specialEvent': 1 } }\n        );\n    }\n\n    // ---------------- EVENT 1: THIEF GAME ----------------\n\n    async startThiefGame(channel, dbEntry, members, logEventFunc) {\n        const membersArray = Array.from(members.values());\n        const thief = membersArray[Math.floor(Math.random() * membersArray.length)];\n        let totalStolen = 0;\n        const lossDescriptions = [];\n\n        // Steal from each player\n        for (const member of membersArray) {\n            let userMoney = await Currency.findOne({ userId: member.id });\n            if (!userMoney) {\n                userMoney = await Currency.create({\n                    userId: member.id,\n                    usertag: member.user.tag,\n                    money: 0\n                });\n            }\n\n            if (userMoney.money > 0) {\n                const percentToSteal = Math.floor(Math.random() * 15) + 10; // 10-25%\n                const stolen = Math.floor((percentToSteal / 100) * userMoney.money);\n                userMoney.money -= stolen;\n                totalStolen += stolen;\n                await userMoney.save();\n                lossDescriptions.push(`${member.displayName} lost ${stolen} coins`);\n            }\n        }\n\n        // Update event data with thief info\n        await gachaVC.updateOne(\n            { channelId: channel.id },\n            {\n                $set: {\n                    'gameData.specialEvent.thiefId': thief.id,\n                    'gameData.specialEvent.stolenAmount': totalStolen\n                }\n            }\n        );\n\n        // Create vote entries\n        const Vote = require('../models/votes');\n        for (const member of membersArray) {\n            await Vote.create({\n                channelId: channel.id,\n                userId: member.id,\n                targetId: 'novote'\n            });\n        }\n\n        // Send public announcement\n        const endTimeSeconds = Math.floor(dbEntry.gameData.specialEvent.endTime.getTime() / 1000);\n        const embed = new EmbedBuilder()\n            .setTitle('üïµÔ∏è THIEF IN THE MINES!')\n            .setDescription(\n                `During the break, someone has been stealing from the camp!\\n\\n` +\n                lossDescriptions.join('\\n') +\n                `\\n\\nüí∞ Total stolen: ${totalStolen} coins\\n\\n` +\n                `Use **/vote** to catch the thief before they escape!`\n            )\n            .addFields({ name: 'Time Remaining', value: `<t:${endTimeSeconds}:R>` })\n            .setColor(0xFF0000)\n            .setTimestamp();\n\n        await channel.send({ embeds: [embed] });\n        await logEventFunc(channel, `üïµÔ∏è THIEF EVENT: ${totalStolen} coins stolen! Players must vote to catch the thief.`);\n\n        // DM the thief\n        try {\n            await thief.send(\n                `üïµÔ∏è **You are the thief!**\\n\\n` +\n                `You've stolen ${totalStolen} coins from your fellow miners. ` +\n                `Stay hidden and avoid suspicion to keep your loot!`\n            );\n        } catch (error) {\n            console.log(`Could not DM thief: ${thief.user.tag}`);\n        }\n    }\n\n    async endThiefGame(channel, dbEntry, logEventFunc) {\n        const eventData = dbEntry.gameData?.specialEvent;\n        if (!eventData || eventData.type !== 'thief') return;\n\n        const { thiefId, stolenAmount } = eventData;\n        const Vote = require('../models/votes');\n        const votes = await Vote.find({ channelId: channel.id });\n\n        const thiefMember = await channel.guild.members.fetch(thiefId).catch(() => null);\n        const winners = votes.filter(v => v.targetId === thiefId);\n        const totalVoters = votes.length;\n\n        const embed = new EmbedBuilder()\n            .setTitle('üïµÔ∏è Thief Hunt Results')\n            .addFields({ name: 'The Thief Was', value: thiefMember ? `<@${thiefId}>` : 'Unknown' })\n            .setTimestamp();\n\n        if (winners.length === 0) {\n            // Thief escaped\n            let thiefMoney = await Currency.findOne({ userId: thiefId });\n            if (thiefMoney) {\n                thiefMoney.money += stolenAmount;\n                await thiefMoney.save();\n            }\n            embed.setColor(0xFF0000)\n                .setDescription(`The thief escaped with all ${stolenAmount} coins! No one voted correctly.`);\n            await logEventFunc(channel, `üèÉ‚Äç‚ôÇÔ∏è Thief escaped with ${stolenAmount} coins!`);\n        } else if (winners.length === totalVoters && totalVoters > 1) {\n            // Everyone caught the thief - full reward\n            const reward = Math.floor(stolenAmount / winners.length);\n            const winnerNames = [];\n            \n            for (const winner of winners) {\n                let userMoney = await Currency.findOne({ userId: winner.userId });\n                if (userMoney) {\n                    userMoney.money += reward;\n                    await userMoney.save();\n                }\n                const member = await channel.guild.members.fetch(winner.userId).catch(() => null);\n                if (member) winnerNames.push(member.displayName);\n            }\n            \n            embed.setColor(0x00FF00)\n                .setDescription(`Perfect! Everyone caught the thief!\\n\\n**Reward:** ${reward} coins each`);\n            await logEventFunc(channel, `‚úÖ Thief caught by everyone! ${reward} coins awarded to each player.`);\n        } else {\n            // Partial success - split between winners and thief\n            const totalRecipients = winners.length + 1;\n            const reward = Math.floor(stolenAmount / totalRecipients);\n            const winnerNames = [];\n            \n            for (const winner of winners) {\n                let userMoney = await Currency.findOne({ userId: winner.userId });\n                if (userMoney) {\n                    userMoney.money += reward;\n                    await userMoney.save();\n                }\n                const member = await channel.guild.members.fetch(winner.userId).catch(() => null);\n                if (member) winnerNames.push(member.displayName);\n            }\n            \n            // Thief keeps a share\n            let thiefMoney = await Currency.findOne({ userId: thiefId });\n            if (thiefMoney) {\n                thiefMoney.money += reward;\n                await thiefMoney.save();\n            }\n            \n            embed.setColor(0xFFFF00)\n                .setDescription(\n                    `Some players caught the thief!\\n\\n` +\n                    `**Winners:** ${winnerNames.join(', ')}\\n` +\n                    `**Reward:** ${reward} coins each\\n` +\n                    `**Thief's share:** ${reward} coins`\n                );\n            await logEventFunc(channel, `‚öñÔ∏è Partial success! ${winners.length} players and thief each get ${reward} coins.`);\n        }\n\n        await channel.send({ embeds: [embed] });\n        await Vote.deleteMany({ channelId: channel.id });\n    }\n\n    // ---------------- EVENT 2: CAVE-IN ----------------\n\n    async startCaveInEvent(channel, dbEntry, members, logEventFunc) {\n        const membersArray = Array.from(members.values());\n        const trappedCount = Math.min(Math.ceil(membersArray.length / 2), 4);\n        const trapped = [];\n        \n        // Randomly select trapped players\n        for (let i = 0; i < trappedCount; i++) {\n            const randomIndex = Math.floor(Math.random() * membersArray.length);\n            trapped.push(membersArray.splice(randomIndex, 1)[0]);\n        }\n\n        const rescuers = membersArray; // Remaining players\n        const requiredRescues = Math.ceil(trapped.length * 0.7); // Need to rescue 70% to succeed\n\n        await gachaVC.updateOne(\n            { channelId: channel.id },\n            {\n                $set: {\n                    'gameData.specialEvent.trapped': trapped.map(m => m.id),\n                    'gameData.specialEvent.rescuers': rescuers.map(m => m.id),\n                    'gameData.specialEvent.requiredRescues': requiredRescues,\n                    'gameData.specialEvent.rescueProgress': 0\n                }\n            }\n        );\n\n        const endTimeSeconds = Math.floor(dbEntry.gameData.specialEvent.endTime.getTime() / 1000);\n        const embed = new EmbedBuilder()\n            .setTitle('‚õ∞Ô∏è CAVE-IN EMERGENCY!')\n            .setDescription(\n                `Part of the mine has collapsed!\\n\\n` +\n                `**Trapped miners:** ${trapped.map(m => m.displayName).join(', ')}\\n` +\n                `**Rescuers:** ${rescuers.map(m => m.displayName).join(', ')}\\n\\n` +\n                `Rescuers must work together to save at least ${requiredRescues} trapped miners!\\n` +\n                `Use **/mine rescue** to help dig them out!`\n            )\n            .addFields({ name: 'Time Remaining', value: `<t:${endTimeSeconds}:R>` })\n            .setColor(0x8B4513)\n            .setTimestamp();\n\n        await channel.send({ embeds: [embed] });\n        await logEventFunc(channel, `‚õ∞Ô∏è CAVE-IN: ${trapped.length} miners trapped! Rescue mission started.`);\n    }\n\n    async endCaveInEvent(channel, dbEntry, logEventFunc) {\n        const eventData = dbEntry.gameData?.specialEvent;\n        if (!eventData || eventData.type !== 'cave_in') return;\n\n        const { trapped, rescuers, requiredRescues, rescueProgress = 0 } = eventData;\n        const success = rescueProgress >= requiredRescues;\n\n        const embed = new EmbedBuilder()\n            .setTitle('‚õ∞Ô∏è Rescue Mission Results')\n            .setTimestamp();\n\n        if (success) {\n            // Successful rescue - reward all participants\n            const reward = 150; // Base reward\n            const participants = [...trapped, ...rescuers];\n            \n            for (const playerId of participants) {\n                let userMoney = await Currency.findOne({ userId: playerId });\n                if (userMoney) {\n                    userMoney.money += reward;\n                    await userMoney.save();\n                }\n            }\n            \n            embed.setColor(0x00FF00)\n                .setDescription(\n                    `üéâ **Successful Rescue!**\\n\\n` +\n                    `The team worked together to save the trapped miners!\\n` +\n                    `**Reward:** ${reward} coins for all participants`\n                );\n            await logEventFunc(channel, `‚úÖ Rescue successful! All players receive ${reward} coins.`);\n        } else {\n            // Failed rescue - penalty for trapped players\n            const penalty = 100;\n            \n            for (const playerId of trapped) {\n                let userMoney = await Currency.findOne({ userId: playerId });\n                if (userMoney && userMoney.money >= penalty) {\n                    userMoney.money -= penalty;\n                    await userMoney.save();\n                }\n            }\n            \n            embed.setColor(0xFF0000)\n                .setDescription(\n                    `üíÄ **Rescue Failed!**\\n\\n` +\n                    `Not enough miners were saved in time...\\n` +\n                    `**Penalty:** ${penalty} coins lost for trapped miners`\n                );\n            await logEventFunc(channel, `üíÄ Rescue failed! Trapped miners lose ${penalty} coins.`);\n        }\n\n        await channel.send({ embeds: [embed] });\n    }\n\n    // ---------------- EVENT 3: TREASURE HUNT ----------------\n\n    async startTreasureHunt(channel, dbEntry, members, logEventFunc) {\n        const membersArray = Array.from(members.values());\n        const treasureCount = Math.min(Math.ceil(membersArray.length / 2), 5);\n        const treasures = [];\n        \n        // Generate random treasures\n        const treasureTypes = [\n            { name: 'Golden Pickaxe', value: 500, emoji: '‚õèÔ∏è' },\n            { name: 'Gem Cache', value: 300, emoji: 'üíé' },\n            { name: 'Ancient Coins', value: 200, emoji: 'ü™ô' },\n            { name: 'Crystal Formation', value: 400, emoji: 'üîÆ' }\n        ];\n        \n        for (let i = 0; i < treasureCount; i++) {\n            const treasure = treasureTypes[Math.floor(Math.random() * treasureTypes.length)];\n            treasures.push({ ...treasure, id: i, found: false, finder: null });\n        }\n\n        await gachaVC.updateOne(\n            { channelId: channel.id },\n            {\n                $set: {\n                    'gameData.specialEvent.treasures': treasures,\n                    'gameData.specialEvent.hunters': membersArray.map(m => ({ id: m.id, finds: 0 }))\n                }\n            }\n        );\n\n        const endTimeSeconds = Math.floor(dbEntry.gameData.specialEvent.endTime.getTime() / 1000);\n        const embed = new EmbedBuilder()\n            .setTitle('üó∫Ô∏è TREASURE HUNT!')\n            .setDescription(\n                `Ancient treasures have been discovered in the mines!\\n\\n` +\n                `**Available treasures:**\\n` +\n                treasures.map((t, i) => `${t.emoji} ${t.name} - ${t.value} coins`).join('\\n') +\n                `\\n\\nUse **/mine search** to hunt for treasure!`\n            )\n            .addFields({ name: 'Time Remaining', value: `<t:${endTimeSeconds}:R>` })\n            .setColor(0xFFD700)\n            .setTimestamp();\n\n        await channel.send({ embeds: [embed] });\n        await logEventFunc(channel, `üó∫Ô∏è TREASURE HUNT: ${treasureCount} treasures hidden in the mines!`);\n    }\n\n    async endTreasureHunt(channel, dbEntry, logEventFunc) {\n        const eventData = dbEntry.gameData?.specialEvent;\n        if (!eventData || eventData.type !== 'treasure_hunt') return;\n\n        const { treasures = [], hunters = [] } = eventData;\n        const foundTreasures = treasures.filter(t => t.found);\n        const totalValue = foundTreasures.reduce((sum, t) => sum + t.value, 0);\n\n        const embed = new EmbedBuilder()\n            .setTitle('üó∫Ô∏è Treasure Hunt Results')\n            .setTimestamp();\n\n        if (foundTreasures.length === 0) {\n            embed.setColor(0x8B4513)\n                .setDescription('No treasures were found! The secrets of the mine remain hidden...');\n            await logEventFunc(channel, 'üó∫Ô∏è Treasure hunt ended - no treasures found.');\n        } else {\n            const results = foundTreasures.map(t => {\n                const finder = hunters.find(h => h.id === t.finder);\n                return `${t.emoji} ${t.name} - found by <@${t.finder}> (${t.value} coins)`;\n            });\n            \n            embed.setColor(0xFFD700)\n                .setDescription(\n                    `üéâ **Treasures Found!**\\n\\n` +\n                    results.join('\\n') +\n                    `\\n\\n**Total value discovered:** ${totalValue} coins`\n                );\n            await logEventFunc(channel, `üó∫Ô∏è Treasure hunt ended - ${foundTreasures.length} treasures found worth ${totalValue} coins!`);\n        }\n\n        await channel.send({ embeds: [embed] });\n    }\n\n    // ---------------- EVENT 4: GAS LEAK ----------------\n\n    async startGasLeakEvent(channel, dbEntry, members, logEventFunc) {\n        const membersArray = Array.from(members.values());\n        const leakCount = Math.ceil(membersArray.length / 3);\n        const timeLimit = 6 * 60 * 1000; // 6 minutes\n        \n        await gachaVC.updateOne(\n            { channelId: channel.id },\n            {\n                $set: {\n                    'gameData.specialEvent.leaksSealed': 0,\n                    'gameData.specialEvent.leaksRequired': leakCount,\n                    'gameData.specialEvent.sealers': []\n                }\n            }\n        );\n\n        const endTimeSeconds = Math.floor((Date.now() + timeLimit) / 1000);\n        const embed = new EmbedBuilder()\n            .setTitle('üí® TOXIC GAS LEAK!')\n            .setDescription(\n                `Dangerous gas is leaking into the mine!\\n\\n` +\n                `**Gas leaks to seal:** ${leakCount}\\n` +\n                `**Current progress:** 0/${leakCount}\\n\\n` +\n                `Everyone must work together to seal the leaks!\\n` +\n                `Use **/mine seal** to help plug the gas leaks!`\n            )\n            .addFields({ name: 'Time Remaining', value: `<t:${endTimeSeconds}:R>` })\n            .setColor(0x90EE90)\n            .setTimestamp();\n\n        await channel.send({ embeds: [embed] });\n        await logEventFunc(channel, `üí® GAS LEAK: ${leakCount} leaks detected! Emergency sealing required.`);\n    }\n\n    async endGasLeakEvent(channel, dbEntry, logEventFunc) {\n        const eventData = dbEntry.gameData?.specialEvent;\n        if (!eventData || eventData.type !== 'gas_leak') return;\n\n        const { leaksSealed = 0, leaksRequired, sealers = [] } = eventData;\n        const success = leaksSealed >= leaksRequired;\n        const members = channel.members.filter(m => !m.user.bot);\n\n        const embed = new EmbedBuilder()\n            .setTitle('üí® Gas Leak Emergency Results')\n            .setTimestamp();\n\n        if (success) {\n            // Success - reward the sealers\n            const reward = 100;\n            \n            for (const sealerId of sealers) {\n                let userMoney = await Currency.findOne({ userId: sealerId });\n                if (userMoney) {\n                    userMoney.money += reward;\n                    await userMoney.save();\n                }\n            }\n            \n            embed.setColor(0x00FF00)\n                .setDescription(\n                    `‚úÖ **Gas Leaks Sealed!**\\n\\n` +\n                    `The mine is safe thanks to quick teamwork!\\n` +\n                    `**Heroes:** ${sealers.map(id => `<@${id}>`).join(', ')}\\n` +\n                    `**Reward:** ${reward} coins each`\n                );\n            await logEventFunc(channel, `‚úÖ Gas leaks sealed! ${sealers.length} heroes receive ${reward} coins each.`);\n        } else {\n            // Failure - everyone loses health/money\n            const penalty = 75;\n            \n            for (const member of members.values()) {\n                let userMoney = await Currency.findOne({ userId: member.id });\n                if (userMoney && userMoney.money >= penalty) {\n                    userMoney.money -= penalty;\n                    await userMoney.save();\n                }\n            }\n            \n            embed.setColor(0xFF0000)\n                .setDescription(\n                    `‚ò†Ô∏è **Gas Leak Disaster!**\\n\\n` +\n                    `The toxic gas overwhelmed the mine!\\n` +\n                    `Only ${leaksSealed}/${leaksRequired} leaks were sealed in time.\\n` +\n                    `**Penalty:** ${penalty} coins lost for all miners`\n                );\n            await logEventFunc(channel, `‚ò†Ô∏è Gas leak disaster! All miners lose ${penalty} coins.`);\n        }\n\n        await channel.send({ embeds: [embed] });\n    }\n}\n\n// Export singleton instance\nmodule.exports = new LongBreakEventManager();