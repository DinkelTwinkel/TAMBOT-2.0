// generateMiningProcedural_enhanced.js - Enhanced with new tile types
const { createCanvas, loadImage } = require('canvas');
const gachaVC = require('../models/activevcs');
const getPlayerStats = require('./calculatePlayerStat');
const itemSheet = require('../data/itemSheet.json');
const PlayerInventory = require('../models/inventory');
const path = require('path');

// Constants
const BASE_TILE_SIZE = 64;
const PLAYER_AVATAR_SIZE = 50;
const STACKED_OFFSET = 10;

// Image optimization constants
const MAX_IMAGE_WIDTH = 5000;
const MAX_IMAGE_HEIGHT = 5000;
const MIN_TILE_SIZE = 16;
const JPEG_QUALITY = 0.8;
const USE_JPEG_THRESHOLD = 300;
const BORDER_SIZE = 5;

// Enhanced tile types (updated to match mining_optimized_v2.js)\nconst TILE_TYPES = {\n    WALL: 'wall',\n    FLOOR: 'floor', \n    ENTRANCE: 'entrance',\n    WALL_WITH_ORE: 'wall_ore',\n    RARE_ORE: 'rare_ore',           // New: High-value ore nodes\n    TREASURE_CHEST: 'treasure',    // New: Special treasure finds\n    HAZARD: 'hazard',              // New: Dangerous tiles\n    REINFORCED_WALL: 'reinforced'  // New: Harder to break walls\n};\n\n// Tile image paths (REPLACE THESE WITH YOUR ACTUAL IMAGE FILES)\nconst TILE_IMAGES = {\n    [TILE_TYPES.WALL]: './assets/tiles/wall.png',                    // Standard stone wall\n    [TILE_TYPES.FLOOR]: './assets/tiles/floor.png',                 // Cleared floor tiles\n    [TILE_TYPES.ENTRANCE]: './assets/tiles/entrance.png',           // Mine entrance\n    [TILE_TYPES.WALL_WITH_ORE]: './assets/tiles/ore_wall.png',      // Wall with visible ore veins\n    [TILE_TYPES.RARE_ORE]: './assets/tiles/rare_ore.png',           // Rare crystalline ore formations\n    [TILE_TYPES.TREASURE_CHEST]: './assets/tiles/treasure.png',     // Treasure chest\n    [TILE_TYPES.HAZARD]: './assets/tiles/hazard.png',               // Dangerous area (spikes, gas, etc.)\n    [TILE_TYPES.REINFORCED_WALL]: './assets/tiles/reinforced.png'   // Extra tough wall\n};\n\n// Fallback colors when images aren't available\nconst TILE_COLORS = {\n    [TILE_TYPES.WALL]: '#444444',\n    [TILE_TYPES.FLOOR]: '#DDDDDD',\n    [TILE_TYPES.ENTRANCE]: '#FF4444',\n    [TILE_TYPES.WALL_WITH_ORE]: '#444444', // Base color, ore will be overlaid\n    [TILE_TYPES.RARE_ORE]: '#6A0DAD',      // Purple for rare ore\n    [TILE_TYPES.TREASURE_CHEST]: '#FFD700', // Gold for treasure\n    [TILE_TYPES.HAZARD]: '#FF0000',        // Red for danger\n    [TILE_TYPES.REINFORCED_WALL]: '#2F2F2F' // Darker gray for reinforced\n};\n\n// Configuration: Set to true to use images, false for colors\nconst USE_TILE_IMAGES = false; // Change to true when you have tile images ready\n\n// Cache for loaded tile images\nconst tileImageCache = new Map();\n\n/**\n * Load and cache a tile image\n */\nasync function loadTileImage(tileType) {\n    if (!USE_TILE_IMAGES) return null;\n    \n    if (tileImageCache.has(tileType)) {\n        return tileImageCache.get(tileType);\n    }\n    \n    try {\n        const imagePath = TILE_IMAGES[tileType];\n        if (!imagePath) return null;\n        \n        const image = await loadImage(imagePath);\n        tileImageCache.set(tileType, image);\n        return image;\n    } catch (error) {\n        console.warn(`Failed to load tile image for ${tileType}:`, error.message);\n        tileImageCache.set(tileType, null); // Cache the failure\n        return null;\n    }\n}\n\n/**\n * Calculate optimal tile size and output format based on map dimensions\n */\nfunction calculateOptimalImageSettings(mapWidth, mapHeight) {\n    let tileSize = BASE_TILE_SIZE;\n    let outputWidth = mapWidth * tileSize;\n    let outputHeight = mapHeight * tileSize;\n    \n    const availableWidth = MAX_IMAGE_WIDTH - (BORDER_SIZE * 2);\n    const availableHeight = MAX_IMAGE_HEIGHT - (BORDER_SIZE * 2);\n    \n    const widthScale = availableWidth / outputWidth;\n    const heightScale = availableHeight / outputHeight;\n    const minScale = Math.min(widthScale, heightScale, 1);\n    \n    if (minScale < 1) {\n        tileSize = Math.max(MIN_TILE_SIZE, Math.floor(tileSize * minScale));\n        outputWidth = mapWidth * tileSize;\n        outputHeight = mapHeight * tileSize;\n    }\n    \n    const finalWidth = outputWidth + (BORDER_SIZE * 2);\n    const finalHeight = outputHeight + (BORDER_SIZE * 2);\n    const useJPEG = (finalWidth > USE_JPEG_THRESHOLD || finalHeight > USE_JPEG_THRESHOLD);\n    \n    return {\n        tileSize,\n        outputWidth,\n        outputHeight,\n        finalWidth,\n        finalHeight,\n        useJPEG,\n        scaleFactor: minScale,\n        playerAvatarSize: Math.max(12, Math.floor(PLAYER_AVATAR_SIZE * minScale)),\n        stackedOffset: Math.max(3, Math.floor(STACKED_OFFSET * minScale))\n    };\n}\n\n/**\n * Enhanced visibility calculation matching the new mining system\n */\nfunction calculateVisibleTiles(position, sightRadius, tiles, imageSettings) {\n    const visible = new Set();\n    const { x: px, y: py } = position;\n    \n    visible.add(`${px},${py}`);\n    \n    if (sightRadius <= 0) {\n        // Basic visibility: current tile + adjacent in 8 directions\n        for (let dx = -1; dx <= 1; dx++) {\n            for (let dy = -1; dy <= 1; dy++) {\n                const newX = px + dx;\n                const newY = py + dy;\n                if (newY >= 0 && newY < tiles.length && \n                    newX >= 0 && newX < tiles[0].length) {\n                    visible.add(`${newX},${newY}`);\n                }\n            }\n        }\n        return visible;\n    }\n    \n    // Enhanced ray casting for better visibility\n    const rayCount = Math.min(64, sightRadius * 8);\n    for (let i = 0; i < rayCount; i++) {\n        const angle = (i * 360) / rayCount;\n        const radians = (angle * Math.PI) / 180;\n        const dx = Math.cos(radians);\n        const dy = Math.sin(radians);\n        \n        for (let dist = 1; dist <= sightRadius; dist++) {\n            const checkX = Math.round(px + dx * dist);\n            const checkY = Math.round(py + dy * dist);\n            \n            if (checkY < 0 || checkY >= tiles.length || \n                checkX < 0 || checkX >= tiles[0].length) {\n                break;\n            }\n            \n            visible.add(`${checkX},${checkY}`);\n            \n            const tile = tiles[checkY][checkX];\n            if (tile && (tile.type === TILE_TYPES.WALL || \n                       tile.type === TILE_TYPES.WALL_WITH_ORE ||\n                       tile.type === TILE_TYPES.REINFORCED_WALL)) {\n                break; // Stop ray at walls\n            }\n        }\n    }\n    \n    return visible;\n}\n\n/**\n * Enhanced tile drawing with support for new tile types\n */\nasync function drawTile(ctx, tile, pixelX, pixelY, tileSize, isVisible, wasDiscovered) {\n    if (!isVisible && !wasDiscovered) return;\n    \n    const alpha = isVisible ? 1.0 : 0.4;\n    ctx.globalAlpha = alpha;\n    \n    // Try to load and use tile image\n    const tileImage = await loadTileImage(tile.type);\n    \n    if (tileImage) {\n        // Draw tile image\n        ctx.drawImage(tileImage, pixelX, pixelY, tileSize, tileSize);\n    } else {\n        // Fallback to color-based rendering\n        await drawTileWithColors(ctx, tile, pixelX, pixelY, tileSize, isVisible, wasDiscovered);\n    }\n    \n    // Add special effects for certain tiles\n    await addTileEffects(ctx, tile, pixelX, pixelY, tileSize, isVisible);\n    \n    ctx.globalAlpha = 1.0;\n}\n\n/**\n * Color-based tile rendering (fallback or when USE_TILE_IMAGES is false)\n */\nasync function drawTileWithColors(ctx, tile, pixelX, pixelY, tileSize, isVisible, wasDiscovered) {\n    let tileColor = TILE_COLORS[tile.type] || '#000000';\n    \n    // Special handling for certain tile types\n    switch (tile.type) {\n        case TILE_TYPES.WALL_WITH_ORE:\n            if (wasDiscovered) {\n                // Draw wall background\n                ctx.fillStyle = TILE_COLORS[TILE_TYPES.WALL];\n                ctx.fillRect(pixelX, pixelY, tileSize, tileSize);\n                \n                // Draw ore veins\n                const oreSize = Math.max(4, tileSize * 0.5);\n                const oreOffset = (tileSize - oreSize) / 2;\n                \n                if (tileSize < 32) {\n                    ctx.fillStyle = '#FFD700';\n                } else {\n                    const gradient = ctx.createLinearGradient(\n                        pixelX + oreOffset, pixelY + oreOffset,\n                        pixelX + oreOffset + oreSize, pixelY + oreOffset + oreSize\n                    );\n                    gradient.addColorStop(0, '#FFD700');\n                    gradient.addColorStop(0.5, '#FFA500');\n                    gradient.addColorStop(1, '#FF8C00');\n                    ctx.fillStyle = gradient;\n                }\n                \n                ctx.fillRect(pixelX + oreOffset, pixelY + oreOffset, oreSize, oreSize);\n                \n                if (tileSize >= 24) {\n                    ctx.strokeStyle = '#FFD700';\n                    ctx.lineWidth = Math.max(1, Math.floor(tileSize / 32));\n                    ctx.strokeRect(pixelX + oreOffset, pixelY + oreOffset, oreSize, oreSize);\n                }\n                return;\n            } else {\n                tileColor = '#333300';\n            }\n            break;\n            \n        case TILE_TYPES.RARE_ORE:\n            if (wasDiscovered) {\n                // Create shimmering effect for rare ore\n                const gradient = ctx.createRadialGradient(\n                    pixelX + tileSize/2, pixelY + tileSize/2, 0,\n                    pixelX + tileSize/2, pixelY + tileSize/2, tileSize/2\n                );\n                gradient.addColorStop(0, '#9932CC'); // Dark orchid center\n                gradient.addColorStop(0.5, '#6A0DAD'); // Blue violet\n                gradient.addColorStop(1, '#4B0082'); // Indigo edge\n                ctx.fillStyle = gradient;\n            } else {\n                tileColor = '#2D1B69'; // Dark purple when not fully visible\n            }\n            break;\n            \n        case TILE_TYPES.TREASURE_CHEST:\n            if (wasDiscovered) {\n                // Golden treasure chest\n                const gradient = ctx.createLinearGradient(\n                    pixelX, pixelY,\n                    pixelX + tileSize, pixelY + tileSize\n                );\n                gradient.addColorStop(0, '#FFD700'); // Gold\n                gradient.addColorStop(0.5, '#FFA500'); // Orange\n                gradient.addColorStop(1, '#B8860B'); // Dark goldenrod\n                ctx.fillStyle = gradient;\n            } else {\n                tileColor = '#8B6914'; // Darker gold when not visible\n            }\n            break;\n            \n        case TILE_TYPES.HAZARD:\n            if (wasDiscovered) {\n                // Animated hazard pattern (alternating stripes)\n                const time = Date.now() * 0.005;\n                const stripe1 = Math.sin(time) > 0 ? '#FF0000' : '#8B0000';\n                const stripe2 = Math.sin(time) > 0 ? '#8B0000' : '#FF0000';\n                \n                // Draw diagonal stripes\n                const stripeWidth = tileSize / 4;\n                for (let i = 0; i < 4; i++) {\n                    ctx.fillStyle = i % 2 === 0 ? stripe1 : stripe2;\n                    ctx.fillRect(pixelX, pixelY + i * stripeWidth, tileSize, stripeWidth);\n                }\n                return;\n            } else {\n                tileColor = '#4D0000'; // Dark red when not visible\n            }\n            break;\n            \n        case TILE_TYPES.REINFORCED_WALL:\n            if (wasDiscovered) {\n                // Reinforced wall with metallic look\n                const gradient = ctx.createLinearGradient(\n                    pixelX, pixelY,\n                    pixelX + tileSize, pixelY + tileSize\n                );\n                gradient.addColorStop(0, '#696969'); // Dim gray\n                gradient.addColorStop(0.3, '#2F2F2F'); // Very dark gray\n                gradient.addColorStop(0.7, '#1C1C1C'); // Almost black\n                gradient.addColorStop(1, '#2F2F2F'); // Very dark gray\n                ctx.fillStyle = gradient;\n            } else {\n                tileColor = '#1A1A1A'; // Very dark when not visible\n            }\n            break;\n    }\n    \n    // Draw the base tile\n    ctx.fillStyle = tileColor;\n    ctx.fillRect(pixelX, pixelY, tileSize, tileSize);\n}\n\n/**\n * Add special visual effects to tiles\n */\nasync function addTileEffects(ctx, tile, pixelX, pixelY, tileSize, isVisible) {\n    if (!isVisible || tileSize < 20) return;\n    \n    switch (tile.type) {\n        case TILE_TYPES.TREASURE_CHEST:\n            // Add sparkle effect\n            const sparkles = 3;\n            ctx.fillStyle = '#FFFFFF';\n            for (let i = 0; i < sparkles; i++) {\n                const sparkleX = pixelX + Math.random() * tileSize;\n                const sparkleY = pixelY + Math.random() * tileSize;\n                const sparkleSize = Math.random() * 3 + 1;\n                ctx.fillRect(sparkleX, sparkleY, sparkleSize, sparkleSize);\n            }\n            break;\n            \n        case TILE_TYPES.RARE_ORE:\n            // Add crystal shine effect\n            ctx.save();\n            ctx.globalAlpha = 0.3;\n            ctx.fillStyle = '#FFFFFF';\n            const shineSize = tileSize * 0.2;\n            ctx.fillRect(\n                pixelX + tileSize * 0.7, \n                pixelY + tileSize * 0.2, \n                shineSize, \n                shineSize * 3\n            );\n            ctx.restore();\n            break;\n            \n        case TILE_TYPES.HAZARD:\n            // Add warning symbols\n            if (tileSize >= 32) {\n                ctx.save();\n                ctx.fillStyle = '#FFFF00'; // Yellow warning\n                ctx.font = `bold ${Math.floor(tileSize * 0.4)}px Arial`;\n                ctx.textAlign = 'center';\n                ctx.textBaseline = 'middle';\n                ctx.fillText('!', pixelX + tileSize/2, pixelY + tileSize/2);\n                ctx.restore();\n            }\n            break;\n            \n        case TILE_TYPES.REINFORCED_WALL:\n            // Add metallic bolts/rivets\n            if (tileSize >= 24) {\n                ctx.fillStyle = '#C0C0C0'; // Silver\n                const rivetSize = Math.max(2, tileSize * 0.08);\n                const positions = [\n                    [0.2, 0.2], [0.8, 0.2],\n                    [0.2, 0.8], [0.8, 0.8]\n                ];\n                \n                positions.forEach(([relX, relY]) => {\n                    const rivetX = pixelX + tileSize * relX - rivetSize/2;\n                    const rivetY = pixelY + tileSize * relY - rivetSize/2;\n                    ctx.fillRect(rivetX, rivetY, rivetSize, rivetSize);\n                });\n            }\n            break;\n    }\n}\n\n/**\n * Groups players by their tile position\n */\nfunction groupPlayersByTile(members, playerPositions) {\n    const tileGroups = {};\n    \n    for (const member of members.values()) {\n        const position = playerPositions[member.id];\n        if (!position) continue;\n        \n        const key = `${position.x},${position.y}`;\n        if (!tileGroups[key]) {\n            tileGroups[key] = [];\n        }\n        tileGroups[key].push(member);\n    }\n    \n    return tileGroups;\n}\n\n/**\n * Enhanced avatar drawing with pickaxe display\n */\nasync function drawPlayerAvatar(ctx, member, centerX, centerY, size, imageSettings) {\n    try {\n        const avatarSize = imageSettings.scaleFactor < 0.5 ? 64 : 128;\n        const avatarURL = member.user.displayAvatarURL({ extension: 'png', size: avatarSize });\n        const avatar = await loadImage(avatarURL);\n        \n        const radius = size / 2;\n        \n        // Draw shadow for larger images\n        if (size > 20) {\n            ctx.fillStyle = 'rgba(0, 0, 0, 0.4)';\n            ctx.beginPath();\n            ctx.arc(centerX + 1, centerY + 1, radius + 1, 0, Math.PI * 2);\n            ctx.fill();\n        }\n        \n        // Draw circular avatar\n        ctx.save();\n        ctx.beginPath();\n        ctx.arc(centerX, centerY, radius, 0, Math.PI * 2, true);\n        ctx.closePath();\n        ctx.clip();\n        \n        ctx.drawImage(avatar, centerX - radius, centerY - radius, size, size);\n        ctx.restore();\n        \n        // Draw border\n        ctx.beginPath();\n        ctx.arc(centerX, centerY, radius, 0, Math.PI * 2, true);\n        ctx.strokeStyle = '#FFFFFF';\n        ctx.lineWidth = Math.max(1, Math.floor(imageSettings.scaleFactor * 2));\n        ctx.stroke();\n\n        // Draw pickaxe if available\n        try {\n            const bestPickaxe = await getBestMiningPickaxe(member.user.id);\n            if (bestPickaxe && bestPickaxe.image && size > 24) {\n                const pickaxeImagePath = `./assets/items/${bestPickaxe.image}.png`;\n                const pickaxeImage = await loadImage(pickaxeImagePath);\n                \n                const pickaxeSize = size * 0.8;\n                const pickaxeX = centerX - radius - 35;\n                const pickaxeY = centerY - pickaxeSize/2;\n                \n                ctx.save();\n                ctx.globalAlpha = 0.9;\n                ctx.drawImage(pickaxeImage, pickaxeX, pickaxeY, pickaxeSize, pickaxeSize);\n                ctx.restore();\n\n                // Show mining power\n                const miningAbility = bestPickaxe.abilities?.find(a => a.name === 'mining');\n                if (miningAbility && miningAbility.powerlevel && size > 30) {\n                    ctx.save();\n                    ctx.font = `bold ${Math.floor(size * 0.25)}px Arial`;\n                    ctx.fillStyle = '#FFD700';\n                    ctx.strokeStyle = '#000000';\n                    ctx.lineWidth = 2;\n                    ctx.textAlign = 'center';\n                    \n                    const powerText = `+${miningAbility.powerlevel}`;\n                    const textX = centerX;\n                    const textY = centerY - radius - 8;\n                    \n                    ctx.strokeText(powerText, textX, textY);\n                    ctx.fillText(powerText, textX, textY);\n                    ctx.restore();\n                }\n            }\n        } catch (error) {\n            console.error(`Error loading pickaxe for user ${member.user.username}:`, error);\n        }\n\n        return true;\n    } catch (error) {\n        console.error(`Error loading avatar for ${member.user.username}:`, error);\n        \n        // Draw placeholder\n        const radius = size / 2;\n        ctx.fillStyle = '#666666';\n        ctx.beginPath();\n        ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);\n        ctx.fill();\n        \n        ctx.fillStyle = '#FFFFFF';\n        ctx.font = `${Math.floor(size * 0.4)}px Arial`;\n        ctx.textAlign = 'center';\n        ctx.textBaseline = 'middle';\n        ctx.fillText(member.displayName.charAt(0).toUpperCase(), centerX, centerY);\n        \n        return false;\n    }\n}\n\n/**\n * Enhanced entrance marker\n */\nfunction drawEntranceMarker(ctx, pixelX, pixelY, tileSize, isVisible, wasDiscovered) {\n    if (!wasDiscovered || tileSize < 20) return;\n    \n    const triangleX = pixelX + tileSize/2;\n    const triangleY = pixelY + tileSize/2;\n    const triangleSize = Math.min(15, tileSize * 0.3);\n    \n    ctx.save();\n    ctx.globalAlpha = isVisible ? 1.0 : 0.4;\n    \n    // Draw upward-pointing triangle\n    ctx.beginPath();\n    ctx.moveTo(triangleX, triangleY - triangleSize); // Top point\n    ctx.lineTo(triangleX - triangleSize, triangleY + triangleSize); // Bottom left\n    ctx.lineTo(triangleX + triangleSize, triangleY + triangleSize); // Bottom right\n    ctx.closePath();\n    \n    ctx.fillStyle = '#FFFFFF';\n    ctx.fill();\n    ctx.strokeStyle = '#000000';\n    ctx.lineWidth = Math.max(1, tileSize * 0.03);\n    ctx.stroke();\n    \n    ctx.restore();\n}\n\n/**\n * Main function to generate enhanced mining map\n */\nasync function generateTileMapImage(channel) {\n    if (!channel?.isVoiceBased()) throw new Error('Channel must be a voice channel');\n\n    const result = await gachaVC.findOne({ channelId: channel.id });\n    if (!result || !result.gameData || !result.gameData.map) {\n        throw new Error('No map data found for this channel');\n    }\n\n    const mapData = result.gameData.map;\n    const { tiles, width, height, playerPositions } = mapData;\n    \n    const imageSettings = calculateOptimalImageSettings(width, height);\n    const { tileSize, outputWidth, outputHeight, finalWidth, finalHeight, useJPEG, playerAvatarSize, stackedOffset } = imageSettings;\n    \n    console.log(`Generating enhanced mining map: ${finalWidth}x${finalHeight} (${useJPEG ? 'JPEG' : 'PNG'})`);\n    \n    const canvas = createCanvas(finalWidth, finalHeight);\n    const ctx = canvas.getContext('2d');\n    ctx.imageSmoothingEnabled = false;\n\n    // Draw border\n    ctx.fillStyle = '#333333';\n    ctx.fillRect(0, 0, finalWidth, finalHeight);\n\n    // Set up main map area\n    ctx.save();\n    ctx.translate(BORDER_SIZE, BORDER_SIZE);\n\n    // Get players and calculate visibility\n    const members = channel.members.filter(m => !m.user.bot);\n    const playerSightInfo = new Map();\n    const allVisibleTiles = new Set();\n    \n    for (const member of members.values()) {\n        const position = playerPositions[member.id];\n        if (!position) continue;\n        \n        const playerData = await getPlayerStats(member.id);\n        const sightRadius = playerData.stats.sight || 0;\n        playerSightInfo.set(member.id, sightRadius);\n        \n        const visibleTiles = calculateVisibleTiles(position, sightRadius, tiles, imageSettings);\n        for (const tile of visibleTiles) {\n            allVisibleTiles.add(tile);\n        }\n    }\n\n    // Fill background (fog of war)\n    ctx.fillStyle = '#111111';\n    ctx.fillRect(0, 0, outputWidth, outputHeight);\n\n    // Draw tiles with enhanced rendering\n    for (let y = 0; y < height; y++) {\n        for (let x = 0; x < width; x++) {\n            const tile = tiles[y] && tiles[y][x];\n            if (!tile) continue;\n\n            const pixelX = x * tileSize;\n            const pixelY = y * tileSize;\n            const tileKey = `${x},${y}`;\n            \n            const isCurrentlyVisible = allVisibleTiles.has(tileKey);\n            const wasDiscovered = tile.discovered;\n            \n            if (!isCurrentlyVisible && !wasDiscovered) continue;\n            \n            // Draw the tile\n            await drawTile(ctx, tile, pixelX, pixelY, tileSize, isCurrentlyVisible, wasDiscovered);\n            \n            // Draw entrance marker\n            if (tile.type === TILE_TYPES.ENTRANCE) {\n                drawEntranceMarker(ctx, pixelX, pixelY, tileSize, isCurrentlyVisible, wasDiscovered);\n            }\n            \n            // Draw grid lines for larger tiles\n            if (isCurrentlyVisible && tileSize >= 24) {\n                ctx.strokeStyle = '#666666';\n                ctx.lineWidth = Math.max(0.5, imageSettings.scaleFactor);\n                ctx.globalAlpha = 0.5;\n                ctx.strokeRect(pixelX, pixelY, tileSize, tileSize);\n                ctx.globalAlpha = 1.0;\n            }\n        }\n    }\n\n    // Draw grid overlay for larger images\n    if (tileSize >= 32) {\n        ctx.strokeStyle = '#333333';\n        ctx.lineWidth = 0.5;\n        ctx.globalAlpha = 0.2;\n        \n        for (let x = 0; x <= width; x++) {\n            ctx.beginPath();\n            ctx.moveTo(x * tileSize, 0);\n            ctx.lineTo(x * tileSize, height * tileSize);\n            ctx.stroke();\n        }\n        \n        for (let y = 0; y <= height; y++) {\n            ctx.beginPath();\n            ctx.moveTo(0, y * tileSize);\n            ctx.lineTo(width * tileSize, y * tileSize);\n            ctx.stroke();\n        }\n        \n        ctx.globalAlpha = 1.0;\n    }\n\n    // Draw players\n    const playerGroups = groupPlayersByTile(members, playerPositions);\n    \n    for (const [tileKey, playersOnTile] of Object.entries(playerGroups)) {\n        const [tileX, tileY] = tileKey.split(',').map(Number);\n        const tileCenterX = tileX * tileSize + tileSize / 2;\n        const tileCenterY = tileY * tileSize + tileSize / 2;\n        \n        if (playersOnTile.length === 1) {\n            const member = playersOnTile[0];\n            await drawPlayerAvatar(ctx, member, tileCenterX, tileCenterY, playerAvatarSize, imageSettings);\n            \n            // Draw player name for larger images\n            if (tileSize >= 40) {\n                ctx.fillStyle = '#FFFFFF';\n                ctx.strokeStyle = '#000000';\n                ctx.font = `${Math.max(8, Math.floor(tileSize * 0.17))}px Arial`;\n                ctx.textAlign = 'center';\n                ctx.lineWidth = Math.max(1, Math.floor(imageSettings.scaleFactor * 2));\n                const nameY = tileCenterY + playerAvatarSize/2 + Math.max(8, tileSize * 0.2);\n                ctx.strokeText(member.displayName, tileCenterX, nameY);\n                ctx.fillText(member.displayName, tileCenterX, nameY);\n            }\n            \n        } else {\n            // Handle multiple players on same tile\n            const totalPlayers = playersOnTile.length;\n            \n            if (tileSize >= 32) {\n                // Arrange in circle for larger images\n                const radius = Math.min(stackedOffset * Math.min(totalPlayers - 1, 5), tileSize * 0.3);\n                const angleStep = (Math.PI * 2) / totalPlayers;\n                \n                for (let i = 0; i < totalPlayers; i++) {\n                    const member = playersOnTile[i];\n                    const angle = angleStep * i - Math.PI / 2;\n                    const offsetX = Math.cos(angle) * radius;\n                    const offsetY = Math.sin(angle) * radius;\n                    \n                    const playerX = tileCenterX + offsetX;\n                    const playerY = tileCenterY + offsetY;\n                    \n                    const avatarSize = Math.max(12, playerAvatarSize - Math.min(totalPlayers * 2, 10));\n                    await drawPlayerAvatar(ctx, member, playerX, playerY, avatarSize, imageSettings);\n                }\n            } else {\n                // Single avatar with count for smaller images\n                const member = playersOnTile[0];\n                await drawPlayerAvatar(ctx, member, tileCenterX, tileCenterY, playerAvatarSize, imageSettings);\n            }\n            \n            // Draw player count\n            ctx.fillStyle = '#FFD700';\n            ctx.strokeStyle = '#000000';\n            ctx.font = `bold ${Math.max(10, Math.floor(tileSize * 0.22))}px Arial`;\n            ctx.textAlign = 'center';\n            ctx.lineWidth = Math.max(1, Math.floor(imageSettings.scaleFactor * 3));\n            const countText = `×${totalPlayers}`;\n            const countY = tileCenterY + tileSize/2 - Math.max(3, tileSize * 0.08);\n            ctx.strokeText(countText, tileCenterX, countY);\n            ctx.fillText(countText, tileCenterX, countY);\n        }\n    }\n\n    ctx.restore();\n\n    // Return optimized buffer\n    if (useJPEG) {\n        return canvas.toBuffer('image/jpeg', { quality: JPEG_QUALITY });\n    } else {\n        return canvas.toBuffer('image/png', { compressionLevel: 9 });\n    }\n}\n\n/**\n * Get best mining pickaxe for a player\n */\nasync function getBestMiningPickaxe(userId) {\n    try {\n        const inventory = await PlayerInventory.findOne({ playerId: userId });\n        if (!inventory || !inventory.items || inventory.items.length === 0) {\n            return null;\n        }\n\n        let bestPickaxe = null;\n        let bestMiningPower = 0;\n\n        for (const invItem of inventory.items) {\n            if (invItem.quantity <= 0) continue;\n\n            const item = itemSheet.find(i => i.id === invItem.itemId);\n            if (!item || item.type !== 'pickAxe') continue;\n\n            const miningAbility = item.abilities?.find(a => a.name === 'mining');\n            if (!miningAbility || !miningAbility.powerlevel) continue;\n\n            if (miningAbility.powerlevel > bestMiningPower) {\n                bestMiningPower = miningAbility.powerlevel;\n                bestPickaxe = item;\n            }\n        }\n\n        return bestPickaxe;\n    } catch (error) {\n        console.error(`Error getting best pickaxe for user ${userId}:`, error);\n        return null;\n    }\n}\n\nmodule.exports = generateTileMapImage;